# 埋点的思考

埋点，即事件记录，也称event track，令我在很多的项目需求开发中无比头疼。其令我厌恶的几个原因如下：
- 代码有一定侵入性，且对核心业务逻辑无关
- 埋点条目很多，不总是容易管理
- 埋点需要采集的数据，有时候不容易取得
- 埋点平台多，同一个事件，参数也不会一样

先谈谈在之前，我对这些诟病所采取的一些应对方法。

我采取了以“一个方法对应一个事件”来进行处理，这些方法的入参需要“宽进”，即尽可能传更能囊括可能需要信息的数据结构，可以传尽可能复杂的、大的、重的，而不要总是传基本的数据类型。应当仅在无法从“宽进”的复杂数据结构里取到相关信息，或者不便于取到时，可以传基本数据结构作为入参。
此外，多个平台对同一个事件的埋点逻辑也是均写在这同一个方法里。这样做基本保证了，对原业务代码低入侵（只需调用一行方法即可），同时支持多平台的情景。
此外，对于深层次的例如Adapter中若触发的埋点，需要外部的一些信息时，即针对问题2，我还设计了`EventContext`的工具，其核心是把上下文信息通过`View.setTag`绑定到父级视图中，对于其内部的若干层子级`View`，`EventContext`会从子到父去遍历其`View`的层级结构，寻找到第一个匹配所需数据`class`的`tag`并返回。这种方式便可很大程度解决了要把一些本来不需要，但埋点需要的信息，不再一层一层传递下来的问题。

此外，我在项目中，还对这些方法的集合，以场景归为不同的文件，或者说以Activity归为不同的文件，采用统一的命名规范，统一把这些文件放在一个package中，也很大程度便于未来查找管理。

上面的这些方案，在很长的一段时间基本能满足开发的需要，也能一定程度克服了前面提到的问题。但实际上，我对这样的代码依然不是很能够容忍。因为毫无以为，我认为这样的方案、代码，都是不符合“计算机科学”的思维的。如果“无埋点”方案能够满足要求，“无埋点”方案会更符合“计算机科学”的思维，但目前而言，我们项目并不能接受这样的方案，依然需要对每个需求手动输出很多个“自定义”的事件。

我把目前自己所不能接受的问题归为如下几个：
- 需要不少代码从原来的数据结构中提取出“埋点方案”所需要的埋点参数。
- 需要很多次去调用类似`sendClick`，`sendPv`这样的方法。

我一直在尝试思考通过注解、通过实现一些接口等方法，来试图更加自动化去生成埋点的实现代码。
比如针对一个`Entity`数据结构的定义，里面势必有很多关于`@SerializedName`此类关于Json的Key的注解。如果在也增加一种新的注解譬如`@TrackableFiled("paramKeyInEvent")`，然后再类似`Gson.toJson(Object)`这样去设计一个`TrackableObject.toMap(Object)`或`TrackableObject.toJson(Object)`，就可以直接在很短的方法调用中，将一个数据结构中需要提取出作为埋点参数的信息，并自动组装成`map`或`json string`。当然，有时候要提取的可能是多个数据结构，我们此时可以设计一个`TrackableObject.toMap(Object...)`即可。这里有个前提就是，同一个字段，理论上不该对应埋点信息里的不同的`key`，若实在需要，我们依然可以指定一个`channel`用来表示只提取匹配`channel`的注解的字段作为`key`。此外，对于基本数据类型，我们还需要提供`TrackableObject.create(int, String key)`方便其组装。

此时，会发现，对于任何一个埋点方法，我们的入参此时可以归纳为`sendClick(TrackableObject...)`或`sendClick(channel, TrackableObject...)`即可。

