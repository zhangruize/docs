# React玩一玩

注意，此文说的是React而非React Native，RN方面的请见另外的文章。这里只是Web端所用的React。

## 声明式 vs 命令式

如果稍微接触下React，肯定会感受到JSX的精妙。它就像把Android Data Binding中xml的玩法直接嵌入到了业务代码之中。

声明式的表现是，只需要表达想要什么，对应的数据传入是什么即可。

命令式的表现是，你要一步一步思考如何把数据对应的内容绘制出来。

区别更深一步来讲，声明式的特点在于，你不需要考虑UI变更时要处理的各种细节，而只需要考虑在不同的数据、状态输入下，该返回怎样的视图即可（而不需要考虑视图该如何从上次状态切换到现在应该展示的状态）。至于视图状态切换的工作，则是React内部要完成的主要工作之一，而且是他们认为可以被解耦出来的部分（我觉得很有道理）。

## 视图更新算法

正如上面所说，React有一个很核心的思想是解耦出视图切换时的工作，让开发者只需要关注数据输入所对应的视图结果即可。那么这里势必要有很核心的关于视图切换的算法。[官方介绍文档](https://zh-hans.reactjs.org/docs/reconciliation.html)。

### 树 还是 链表

说到UI元素，其实在不同的层面角度上，所用的数据结构并不相同。对于应用层，我们更适合用树的结构来描述页面的UI元素。而对于系统的图形角度来说，会用到很多队列、链表这种线性结构。后者在看待视图时，各个应用的视图已经被对应的图形引擎整合完成，在系统角度看要渲染的更像是一套图层的列表，比如先渲染壁纸图层、应用图层、状态栏图层、导航栏图层等等。在这里显然已经不是树的结构所擅长的了。

回到React的应用层面上，其diffing算法核心要处理的场景就是树结构的更新。大体上而言如下：

- 根节点类型不同时，重新渲染
- 根节点类型相同时，更新属性

之后便是对子树进行类似递归。此外还有关于列表元素的处理，对每个列表元素的key进行判断，key是用于区分是否可以复用或者保留的标志。

## JSX

JSX在React是很大的亮点之一。通过配套的工具，React使用Babel把JSX语法写出来的片段，最终编译为可以向低版本JS兼容的函数调用。这就好比我们在JS的基础上，又定制了一颗很大的语法糖，这个巧妙的语法糖把声明式的UI发挥到了极致。而Babel则是最终把这颗糖消化掉的核心。如果再调查一下，会看到Babel实际上是为了新规范JS向前兼容的编译器。除了React，还有更棒的产品如TypeScript等已经在用了。我们可以看到这些JS的“变种”最终是如何在Babel编译器下还原成最普通的JS脚本的。

在发布、部署应用的时候，只需要借助Babel即可生成最终的生产代码。至于Babel是否有开发、生产模式之分，我不确定，但感觉可以有。

## PWA

React好像对PWA也支持友好。