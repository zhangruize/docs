# MMKV理解

[多进程](https://github.com/Tencent/MMKV/wiki/android_ipc)

## MMKV原理（mmap + 文件锁 + ProtoBuffer）

使用文件内存映射（mmap），由Linux系统负责什么时候把内存数据写回到文件。采取此方式可以避免其他所有方式在多进程条件下，可能出现的死锁、饿死问题，即持有锁的进程被kill的时候，其他进程无限等待。按原文所说，binder也采取了文件描述符所生成的锁（**文件锁**）解决多进程问题。

## 相比于其他多进程方案

- SharePreference不支持多进程，没有任何机制、措施可以确保多进程同步。
- 按MMKV文档介绍，ContentProvider一个单独进程管理数据，但是启动慢、访问慢。其他socket, pipe, message queue要至少2次内存拷贝。

## 数据同步（写数据、内存重整、内存扩容）

写数据时，所有的新数据以ProtoBuffer形式编码，追加（append）到当前的写指针上。因此内存会变大。即使是相同的key，也是追加的方式。内存的尺寸（分有效尺寸和文件尺寸）会被写入在文件的头部。

内存重整，依然是通过文件头部存储一个递增的序列号，通过比较进程缓存的序列号和文件头部的序列号，即可知道是否发生了内存重整。

内存扩容，在扩容前必先会触发内存重整。而扩容后内存的文件尺寸会变大，进程通过对比缓存的文件尺寸跟当前的文件尺寸即可判断。

进程首先通过对比缓存的序号和当前文件序号是否一致，若不一致，则看缓存的文件大小和当前的是否一致，若不一致则说明是文件扩容，否则只是内存重整。而这两者的处理方式都是完全重新解码覆盖到原来的map。而如果序号一致，只是文件的实际内存尺寸不同，则说明是增加了数据（即使key可以相同），那么则仅把尺寸增加的部分内存取出解码成map，然后遍历覆盖原来的map即可。

## 写入优化

使用ProtoBuffer为了更好的性能和更小的空间。（相比Json, xml）

## OneMoreThing 单进程下vs SharePreference

sp使用了很多synchronize代码块（不是直接修饰方法），来确保多线程同步。此外，apply和commit分别异步/同步把变更写回到文件。