
## 第一次activity的渲染时机
也就是在activityThread#handleResumeActivity的时候，

windowManagerImpl.addView

```
scheduleTraversals:1946, ViewRootImpl (android.view)
requestLayout:1632, ViewRootImpl (android.view)
setView:981, ViewRootImpl (android.view)
addView:399, WindowManagerGlobal (android.view)
addView:95, WindowManagerImpl (android.view)
handleResumeActivity:4638, ActivityThread (android.app)
execute:52, ResumeActivityItem (android.app.servertransaction)
executeLifecycleState:181, TransactionExecutor (android.app.servertransaction)
execute:102, TransactionExecutor (android.app.servertransaction)
handleMessage:2239, ActivityThread$H (android.app)
dispatchMessage:107, Handler (android.os)
loop:237, Looper (android.os)
main:7830, ActivityThread (android.app)
invoke:-1, Method (java.lang.reflect)
run:492, RuntimeInit$MethodAndArgsCaller (com.android.internal.os)
main:1040, ZygoteInit (com.android.internal.os)
```

## draw调用栈

```
onDraw:43, MainActivity$TestView (org.tu.android)
draw:21813, View (android.view)
updateDisplayListIfDirty:20642, View (android.view)
draw:21525, View (android.view)
drawChild:4542, ViewGroup (android.view)
dispatchDraw:4279, ViewGroup (android.view)
draw:21820, View (android.view)
draw:869, DecorView (com.android.internal.policy)
updateDisplayListIfDirty:20642, View (android.view)
updateViewTreeDisplayList:575, ThreadedRenderer (android.view)
updateRootDisplayList:581, ThreadedRenderer (android.view)
draw:654, ThreadedRenderer (android.view)
draw:4129, ViewRootImpl (android.view)
performDraw:3917, ViewRootImpl (android.view)
performTraversals:3223, ViewRootImpl (android.view)
doTraversal:2054, ViewRootImpl (android.view)
run:8459, ViewRootImpl$TraversalRunnable (android.view)
run:1065, Choreographer$CallbackRecord (android.view)
doCallbacks:889, Choreographer (android.view)
doFrame:816, Choreographer (android.view)
run:1050, Choreographer$FrameDisplayEventReceiver (android.view)
handleCallback:883, Handler (android.os)
dispatchMessage:100, Handler (android.os)
loop:237, Looper (android.os)
main:7830, ActivityThread (android.app)
invoke:-1, Method (java.lang.reflect)
run:492, RuntimeInit$MethodAndArgsCaller (com.android.internal.os)
main:1040, ZygoteInit (com.android.internal.os)
```
threadedRendererupdateRootDisplayList


## choreographer 渲染时机

scheduleVsync(native)(from any choreographer.postCallback call. eg: ViewRootImpl#scheduleTraversals) 

dispatchVsync(from native, activity thread, message queue, next.)

```
onVsync:1042, Choreographer$FrameDisplayEventReceiver (android.view)
dispatchVsync:187, DisplayEventReceiver (android.view)
nativePollOnce:-1, MessageQueue (android.os)
next:336, MessageQueue (android.os)
loop:184, Looper (android.os)
main:7830, ActivityThread (android.app)
invoke:-1, Method (java.lang.reflect)
run:492, RuntimeInit$MethodAndArgsCaller (com.android.internal.os)
main:1040, ZygoteInit (com.android.internal.os)
```
choreographer#onVsync-> FrameHandler.message(计算时间延迟)->FrameDisplayEventReceiver#onRun->doFrame

note:

ActivityThread的looper也就是mainLooper是会被多个handler所使用的哦。也就是尽管都复用着一个messageQueue，但是message的target不同（handler不同）。

几个常见的Handler:

- ActivityThread#H 用于处理多个Activity生命周期、application周期相关事情
- Choregrapher#FrameHandler 用于scheduleVsync, doFrame

## 综上渲染概述

- context.getSystemService是来获取当前进程的系统服务“客户端”，一般是xxServiceImpl，而系统服务的“服务端”是在他们自己的进程之中，一般是“xxManagerService”，客户端和服务端通信一般使用binder机制，transact->onTransact->服务端方法实现
- 对于activity也好，dialog也好，或者是类似悬浮窗这种需要在window添加自定义view的，本质上都是`windowManagerService#addView(View, WParam)`，这个View对于activity和dialog来说都是decorView，对于自定义浮窗来说就是自己的view。
    - 在`wm#addView`这个方法里，会通过进程内的单例WindowManagerGlobal来完成具体实现。主要包括创建ViewRootImpl, WParam准备，然后记录到list(View), list(ViewRootImpl), list(WParam)。最后会调用ViewRootImpl#setView.  也就是说，无论是activity, dialog还是自己的view，其实在wm的Add过程中都会被创建一个ViewRootImpl，不过对于activity来说，是在handleResumeActivity的时候。并且会记录只需要创建一次，只有在handleDestroyActivity的时候才调用wm#removeView与之对应。而非pause的时候。
    - 在ViewRootImpl#setView的时候，会处理很多事情，包括requestLayout、准备事件分发stage。而`requestLayout->scheduleTranversals->Choreographer.postCallback->Choreographer#scheduleVsync`，等待下一个Choreographer的`dispatchVsync（会由主线程的looper的messageQueue的next的native来触发回调）-> Choreographer#doFrame->...->ViewRootImpl#performTraversals`(scheduleTraversals方法用到了MessageQueue异步message, 发送了同步栅栏，而在doTraversals的时候删除了栅栏)
    - 在ViewRootImpl#performTraversals的时候，会进行view的measure, layout, draw。draw的时候，硬件绘制会去ThreadedRenderer来进行，其过程包括，ThreadedRenderer#updateRootDisplayList、syncAndDrawFrame(native)，如其所述，先更新displayList，再做nativeSync。软绘的时候是surface的lockCanvas来进行，见ViewRootImpl#drawSoftware。
        - displayList其实顾名思义，就是为了在硬绘时记录绘制指令。这块的canvas是通过RenderNode#beginRecording来获得的RecordingCanvas(extends DisplayListCanvas).
        - 无论是软绘，还是硬绘，这里所述其实都是基于canvas的api的绘制。
        - ViewRootImpl的surface从哪里来？threadedRenderer从哪里来？这些都来自于在ViewRootImpl的构造过程，即WindowManagerGlobal#addView. 在viewRootImpl的构造函数里，会有
        ```java
        mAttachInfo = new View.AttachInfo(mWindowSession, mWindow, display, this, mHandler, this,context);
        ```
        以及如果发现开启了硬件加速的时候
        ``` java
        mAttachInfo.mThreadedRenderer = ThreadedRenderer.create(mContext, translucent,attrs.getTitle().toString());
        ```
        这里会直接走到它的构造方法ThreadedRenderer: HardwareRenderer，搬运一下注释：
        > 创建硬件加速渲染器的实例。 这用于将从RenderNode构建的场景渲染到输出Surface 。 可以根据需要有任意数量的HardwareRenderer实例。
资源和生命周期
所有HardwareRenderer实例共享一个公共的渲染线程。 渲染线程包含执行GPU加速渲染所需的GPU上下文和资源。 这样，创建的第一个HardwareRenderer带有创建关联的GPU上下文的成本，但是此后每个增量的HardwareRenderer都相当便宜。 预期的用法是为每个活动的Surface都有一个HardwareRenderer实例。 例如，当“活动”显示“对话框”时，系统内部将使用2个硬件渲染器，这两个渲染器可能同时绘制。
注意：由于渲染线程具有共享，协作的性质，因此至关重要的是，所使用的任何Surface必须具有迅速，可靠的使用方。 系统提供的使用者，例如android.view.SurfaceView ，android.view.Window.takeSurface(SurfaceHolder.Callback2)或android.view.TextureView均符合此要求。 但是，如果使用自定义使用者（例如在使用SurfaceTexture或android.media.ImageReader ，则应用程序有责任确保他们迅速，迅速地使用更新。 否则，将导致渲染线程停滞在该表面上，从而阻塞所有HardwareRenderer实例
        
    - 所以PhoneWindow又是有何用？关于window的注释：
        > 顶级窗口外观和行为策略的抽象基类。 此类的实例应用作添加到窗口管理器的顶级视图。 它提供了标准的UI策略，例如背景，标题区域，默认键处理等。
此抽象类的唯一现有实现是android.view.PhoneWindow，您需要在需要Window时实例化该实例
    
        思考下我们平时开发中，关于phoneWindow的使用也主要是，`activity#getWindow#getDecorView`, 或者`activity#getWindow#getAttributes#....`因此，很容易看出来，PhoneWindow其实主要是用于管理View结构和窗口的一些属性的(标题、背景色、action_bar..)。


- ActivityThread负责了不止一个activity的生命周期，而是所有此进程的activity。application的生命周期也是由它来负责，先bind application,再会有activity的transaction item，见`ActivityLifecycleItem`包括`StartActivityItem`, `ResumeActivityItem`，实际实现还是在activityThread。目前没有关于`applicationThread`的东西。

# surface flinger

doComposition -> doComposeSurfaces

https://skytoby.github.io/2020/Android%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6-SurfaceFlinger%E5%8E%9F%E7%90%86/

https://betterprogramming.pub/android-internals-for-rendering-a-view-430cd394e225

## SurfaceView
独立线程渲染，有自己的surface。

## eglSurfaceView#GLThread 频率控制
其实是egl#eglSwapBuffer的过程。对于GLSurfaceView，是会通过swapBuffersWithDamageKHR->surface#dequeueBuffer->IGraphicsBufferQueue#dequeueBuffer->跨进程（估计是到surfaceFlinger），这个过程中，surfaceFlinger决定的等待。


而TextureView的egl.eglSwapBuffer频率并不受控制，可能是因为在eglSwapBuffer所传入的eglSurface不同决定的。

profiler图片可以看pics文件夹。

## surface
在surfaceFlinger对应的是layer，拥有bufferQueue。Surface是bufferQueue的生产者，SurfaceFlinger是消费者。


## window, viewRootImpl, decorView

- Activity {window, decorView}
- DecorView {viewRootImpl}
- WindowManagerGlobal {list(decorView), list(ViewRootImpl)}
- Window {DecorView}
- ViewRootImpl {mWindow: W: IWindow.Stub}